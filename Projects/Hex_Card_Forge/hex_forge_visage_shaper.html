<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hex Card Forge - GUI Prototype</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --primary: #4A0072; /* Rich Byzantine Purple */
            --primary-dark: #3A005A;
            --primary-light: #5C4077; /* Dark Lavender */
            --secondary: #DAA520; /* Goldenrod */
            --secondary-dark: #B8860B;
            --secondary-light: #F0C14C; 
            --background: #1A1A2E; /* Dark Imperial Blue */
            --bg-content: #252538; /* Darker content area */
            --bg-content-light: #2C2C44; 
            --text-light: #E0E0E0; 
            --text-medium: #B0B0B0; 
            --text-dark-contrast: #1A1A2E; 
            --border: #404058;
            --border-focus: var(--secondary);
            --text-error: #F87171; 
            --focus-outline-width: 2px;
            --focus-outline-offset: 1px;
            --focus-glow-color: rgba(218, 165, 32, 0.4);
            --spacing-unit: 8px;
            --sidebar-width: 240px;
            --sidebar-width-collapsed: 60px; 
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background);
            color: var(--text-light);
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden; 
            display: flex; 
            flex-direction: column; 
        }
        
        .app-shell { 
            display: flex;
            flex-grow: 1; 
            min-height: 0; 
        }

        .hidden-visually {
            border: 0;
            clip: rect(0 0 0 0);
            height: 1px;
            margin: -1px;
            overflow: hidden;
            padding: 0;
            position: absolute;
            width: 1px;
        }

        .container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 calc(var(--spacing-unit) * 2.5); 
        }

        .screen {
            display: none; 
            opacity: 0;
            animation: screenFadeIn 0.3s ease-out forwards;
            width: 100%;
        }

        .screen.active {
            display: block; 
            opacity: 1;
            z-index: 1; 
        }
        @keyframes screenFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        *:focus-visible {
            outline: var(--focus-outline-width) solid var(--border-focus) !important;
            outline-offset: var(--focus-outline-offset) !important;
            box-shadow: 0 0 0 calc(var(--focus-outline-width) + 2px) var(--focus-glow-color) !important;
        }

        .btn {
            background-color: var(--primary);
            color: var(--text-light);
            border: none;
            padding: calc(var(--spacing-unit) * 1.25) calc(var(--spacing-unit) * 2); 
            border-radius: calc(var(--spacing-unit) * 0.5); 
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-height: 44px;
            min-width: 44px;
        }
        .btn:hover { background-color: var(--primary-dark); }
        .btn:active { transform: scale(0.98); }
        .btn-secondary { background-color: var(--secondary); color: var(--text-dark-contrast); }
        .btn-secondary:hover { background-color: var(--secondary-dark); }
        .btn-neutral { background-color: var(--bg-content-light); color: var(--text-light); border: 1px solid var(--border); }
        .btn-neutral:hover { background-color: var(--border); }
        .btn-danger { background-color: #991B1B; }
        .btn-danger:hover { background-color: #7F1D1D; }
        .btn--icon { padding: var(--spacing-unit); }
        .btn i.fas { margin-right: var(--spacing-unit); }

        .hex-card-shape { 
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        /* App Sidebar (Main Navigation) */
        .app-sidebar {
            width: var(--sidebar-width);
            background-color: var(--primary);
            color: var(--text-light);
            padding: calc(var(--spacing-unit) * 2);
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            transition: transform 0.3s ease-in-out, width 0.3s ease-in-out;
            overflow-y: auto;
            flex-shrink: 0; 
            height: 100vh; 
            position: sticky; 
            top: 0;
        }
        .app-sidebar__header {
            margin-bottom: calc(var(--spacing-unit) * 3);
            text-align: center;
        }
        .app-sidebar__logo h1 {
            font-size: 1.75rem;
            font-weight: 900;
            color: var(--text-light);
        }
        .app-sidebar__logo span { color: var(--secondary); }

        .app-sidebar__nav-list { list-style: none; padding: 0; margin: 0; }
        .app-sidebar__nav-item { margin-bottom: var(--spacing-unit); }
        .app-sidebar__nav-link {
            display: flex;
            align-items: center;
            padding: calc(var(--spacing-unit) * 1.25) var(--spacing-unit);
            border-radius: calc(var(--spacing-unit) * 0.5);
            color: var(--text-light);
            text-decoration: none;
            font-weight: 500;
            transition: background-color 0.2s, color 0.2s;
        }
        .app-sidebar__nav-link i.fas {
            margin-right: calc(var(--spacing-unit) * 1.5);
            width: 20px; 
            text-align: center;
        }
        .app-sidebar__nav-link:hover, .app-sidebar__nav-link:focus-visible {
            background-color: var(--primary-dark);
            color: var(--secondary);
        }
        .app-sidebar__nav-link.active-nav-link {
            background-color: var(--secondary);
            color: var(--text-dark-contrast);
            font-weight: 700;
        }
        .app-sidebar__nav-link.active-nav-link i.fas { color: var(--text-dark-contrast); }

        /* Main Content Area */
        .app-main-content {
            flex-grow: 1;
            background-color: var(--background);
            padding: calc(var(--spacing-unit) * 3);
            overflow-y: auto; 
            height: 100vh; 
        }
        
        .section-title {
            color: var(--secondary);
            margin-bottom: calc(var(--spacing-unit) * 2); 
            border-bottom: 2px solid var(--primary);
            padding-bottom: var(--spacing-unit); 
            font-size: 1.75rem; 
            font-weight: 700;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-unit); 
        }
        .form-group label {
            font-weight: 500;
            color: var(--text-medium);
        }
        .form-control {
            padding: calc(var(--spacing-unit) * 1.25); 
            background-color: var(--bg-content-light);
            border: 1px solid var(--border);
            border-radius: calc(var(--spacing-unit) * 0.5); 
            color: var(--text-light);
            width: 100%;
            min-height: 44px;
        }
        .form-control.input-error {
            border-color: var(--text-error) !important; 
            box-shadow: 0 0 0 1px var(--text-error) !important;
        }
        .error-message-text {
            color: var(--text-error);
            font-size: 0.8rem;
            margin-top: calc(var(--spacing-unit) * 0.5);
        }

        .scriptorium-container, .visage-container, .forge-container, .library-container { 
            display: grid;
            grid-template-columns: 1fr; 
            gap: calc(var(--spacing-unit) * 3); 
            background-color: var(--bg-content);
            padding: calc(var(--spacing-unit) * 2.5); 
            border-radius: var(--spacing-unit); 
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        @media (min-width: 992px) { 
            .scriptorium-container, .visage-container {
                grid-template-columns: minmax(0, 1fr) minmax(0, 1fr); 
            }
            .forge-container { 
                 grid-template-columns: minmax(0, 3fr) minmax(0, 2fr); 
            }
            .library-container { 
                grid-template-columns: 1fr;
            }
        }
        
        /* Visage Shaper Specific Styles */
        .visage-shaper__panel { /* Common for left and right panels */
            display: flex;
            flex-direction: column;
            gap: calc(var(--spacing-unit) * 2);
        }
        .visage-shaper__image-area { /* Container for image and mask */
            width: 100%;
            aspect-ratio: 4 / 3;
            max-height: 450px; /* Max height for the cropping area */
            background-color: var(--bg-content-dark);
            border: 2px dashed var(--border);
            border-radius: var(--spacing-unit);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }
        .visage-shaper__source-image {
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            cursor: grab;
            transform-origin: center; /* For scale and rotation */
            transition: transform 0.1s linear; /* Smooth out direct manipulation a bit */
        }
        .visage-shaper__hex-mask {
            position: absolute;
            width: 50%; /* Initial size, JS will control */
            /* height will be set by JS to maintain aspect ratio */
            border: 2px solid var(--secondary); /* Mask border */
            cursor: move;
            box-sizing: border-box;
            box-shadow: 0 0 0 9999px rgba(0,0,0,0.65); /* Dim area outside mask */
            /* clip-path applied by .hex-card-shape */
            display: flex; /* For resize handles */
            align-items: center;
            justify-content: center;
        }
        .visage-shaper__hex-mask:focus-within { /* Highlight mask when handles are focused */
             border-style: dashed;
        }

        .resize-handle {
            position: absolute;
            width: calc(var(--spacing-unit) * 1.5); 
            height: calc(var(--spacing-unit) * 1.5); 
            background-color: var(--secondary);
            border: 1px solid var(--primary-dark);
            border-radius: 50%;
            z-index: 10;
            /* Individual positioning will be done by JS or more specific CSS */
        }
        /* Conceptual positions for resize handles (JS will place them more accurately) */
        .resize-handle.n { top: calc(var(--spacing-unit) * -0.75); left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resize-handle.s { bottom: calc(var(--spacing-unit) * -0.75); left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resize-handle.e { right: calc(var(--spacing-unit) * -0.75); top: 50%; transform: translateY(-50%); cursor: ew-resize; }
        .resize-handle.w { left: calc(var(--spacing-unit) * -0.75); top: 50%; transform: translateY(-50%); cursor: ew-resize; }
        /* Corner handles are more complex for a hexagon */


        .visage-shaper__control-panel {
            background-color: var(--bg-content-light);
            padding: calc(var(--spacing-unit) * 2);
            border-radius: var(--spacing-unit);
            margin-top: calc(var(--spacing-unit) * 2);
        }
        .control-group {
            margin-bottom: calc(var(--spacing-unit) * 2);
        }
        .control-group label {
            display: block;
            margin-bottom: calc(var(--spacing-unit) * 0.5);
            color: var(--text-medium);
            font-size: 0.9rem;
        }
        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--secondary); 
        }
        .control-group input[type="number"] {
            width: 70px; /* Fixed width for number inputs */
            margin-left: var(--spacing-unit);
        }
        .slider-group { /* For slider and number input side-by-side */
            display: flex;
            align-items: center;
            gap: var(--spacing-unit);
        }
        .slider-group input[type="range"] { flex-grow: 1; }

        .visage-shaper__preview-panel {
             display: flex;
             flex-direction: column;
             align-items: center;
        }
        .visage-shaper__result-preview {
            width: 100%;
            max-width: 250px; /* Max size for preview */
            aspect-ratio: 1 / 1.15; /* Hexagon aspect ratio */
            background-color: var(--bg-content-dark);
            border: 2px solid var(--primary-light); /* Subtle border for preview */
            overflow: hidden;
            background-size: cover;
            background-position: center;
            margin: 0 auto; /* Center it */
        }

        .visage-shaper__actions {
            margin-top: calc(var(--spacing-unit) * 3);
            display: flex;
            justify-content: flex-start; /* Align to start for control panel */
            gap: var(--spacing-unit);
            flex-wrap: wrap;
        }

        /* Other screens' specific styles (condensed for brevity but should exist) */
        /* ... Scriptorium, Obsidian Library, Collection Forge specific styles ... */
        .library-toolbar, .card-grid, .library-pagination, .card-list, .metadata-list { /* Existing styles */ }
        .scriptorium-container .section-title, .visage-container .section-title, .forge-container .section-title, .library-container .section-title {
             /* Consistent section titles */
             color: var(--secondary); margin-bottom: calc(var(--spacing-unit) * 2);
             border-bottom: 2px solid var(--primary); padding-bottom: var(--spacing-unit);
             font-size: 1.5rem; font-weight: 700;
        }


        /* Mobile adjustments for sidebar */
        @media (max-width: 768px) {
            .app-sidebar {
                position: fixed; transform: translateX(-100%); height: 100vh; z-index: 1001; 
            }
            .app-sidebar--open { transform: translateX(0); }
            .app-main-content { width: 100%; }
            .mobile-menu-toggle { 
                display: inline-flex !important; position: fixed;
                top: calc(var(--spacing-unit) * 1.5); left: calc(var(--spacing-unit) * 1.5);
                z-index: 1002; background-color: var(--primary); border: 1px solid var(--secondary);
            }
            body.sidebar-open .app-main-content { /* Optional overlay/shift */ }
            
            /* Stack Visage Shaper panels on mobile */
            .visage-container { grid-template-columns: 1fr; }
            .visage-shaper__preview-panel { margin-top: calc(var(--spacing-unit) * 3); }
            .visage-shaper__control-panel { margin-top: 0; } /* Remove top margin if it's part of the left panel */
        }

    </style>
</head>
<body>
    <div class="app-shell">
        <aside class="app-sidebar" id="appSidebar" role="navigation" aria-label="Main application navigation">
            <div class="app-sidebar__header">
                <div class="app-sidebar__logo">
                    <h1>HEX <span>CARD</span> FORGE</h1>
                </div>
            </div>
            <ul class="app-sidebar__nav-list">
                <li class="app-sidebar__nav-item">
                    <a href="#gateway" class="app-sidebar__nav-link data-nav-link" data-screen="gateway">
                        <i class="fas fa-dungeon"></i> Gateway
                    </a>
                </li>
                <li class="app-sidebar__nav-item">
                    <a href="#obsidian-library" class="app-sidebar__nav-link data-nav-link" data-screen="obsidian-library">
                        <i class="fas fa-book-dead"></i> Library
                    </a>
                </li>
                <li class="app-sidebar__nav-item">
                    <a href="#scriptorium" class="app-sidebar__nav-link data-nav-link" data-screen="scriptorium">
                        <i class="fas fa-scroll"></i> Scriptorium
                    </a>
                </li>
                <li class="app-sidebar__nav-item">
                    <a href="#visage-shaper" class="app-sidebar__nav-link data-nav-link active-nav-link" data-screen="visage-shaper" aria-current="page">
                        <i class="fas fa-crop-alt"></i> Visage Shaper
                    </a>
                </li>
                <li class="app-sidebar__nav-item">
                    <a href="#collection-forge" class="app-sidebar__nav-link data-nav-link" data-screen="collection-forge">
                        <i class="fas fa-archive"></i> Collection Forge
                    </a>
                </li>
            </ul>
        </aside>

        <main class="app-main-content" role="main" id="mainWorkspace">
            <button id="mobileMenuToggle" class="btn btn--icon mobile-menu-toggle" aria-label="Toggle Menu" aria-expanded="false" aria-controls="appSidebar">
                <i class="fas fa-bars"></i>
            </button>

            <section id="gateway" class="screen">
                </section>

            <section id="obsidian-library" class="screen" aria-labelledby="library-main-title" tabindex="-1">
                </section>

            <section id="scriptorium" class="screen content-screen-padding">
                </section>

            <section id="visage-shaper" class="screen active" aria-labelledby="visage-shaper-main-title" tabindex="-1">
                <div class="visage-container">
                    <div class="visage-shaper__panel">
                        <h2 id="original-image-title" class="section-title">Original Image</h2>
                        <div class="form-group">
                            <label for="visageImageUpload" class="hidden-visually">Upload Image for Cropping</label>
                            <input type="file" id="visageImageUpload" class="form-control" accept="image/*">
                            <p id="visageImageError" class="error-message-text" aria-live="assertive"></p>
                        </div>
                        <div class="visage-shaper__image-area" id="visageCroppingAreaContainer" role="application" aria-roledescription="Image cropping canvas">
                            <img id="visageImageToCrop" src="https://placehold.co/600x450/2C2C44/B0B0B0?text=Upload+or+Drag+Image" alt="Image to be cropped">
                            <div id="visageInteractiveHexMask" class="visage-shaper__hex-mask hex-card-shape" tabindex="0" aria-label="Hexagonal crop mask. Draggable. Use handles to resize.">
                                <div class="resize-handle n" data-direction="n" aria-label="Resize North"></div>
                                <div class="resize-handle s" data-direction="s" aria-label="Resize South"></div>
                                <div class="resize-handle e" data-direction="e" aria-label="Resize East"></div>
                                <div class="resize-handle w" data-direction="w" aria-label="Resize West"></div>
                                <div class="resize-handle ne" data-direction="ne" aria-label="Resize North-East"></div>
                                <div class="resize-handle nw" data-direction="nw" aria-label="Resize North-West"></div>
                                <div class="resize-handle se" data-direction="se" aria-label="Resize South-East"></div>
                                <div class="resize-handle sw" data-direction="sw" aria-label="Resize South-West"></div>
                            </div>
                        </div>
                        
                        <div class="visage-shaper__control-panel">
                            <h3 class="section-title" style="font-size: 1.25rem; margin-bottom: var(--spacing-unit);">Adjustments</h3>
                            <div class="control-group">
                                <label for="imageScaleSlider">Image Scale (Zoom): <span id="imageScaleValue">100</span>%</label>
                                <div class="slider-group">
                                    <input type="range" id="imageScaleSlider" class="form-control" min="10" max="300" value="100" aria-labelledby="imageScaleValue">
                                    <input type="number" id="imageScaleNumber" class="form-control" min="10" max="300" value="100" aria-label="Image Scale Percentage">
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="imageRotationSlider">Image Rotation: <span id="imageRotationValue">0</span>°</label>
                                 <div class="slider-group">
                                    <input type="range" id="imageRotationSlider" class="form-control" min="-180" max="180" value="0" aria-labelledby="imageRotationValue">
                                    <input type="number" id="imageRotationNumber" class="form-control" min="-180" max="180" value="0" aria-label="Image Rotation Degrees">
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="maskOpacitySlider">Mask Overlay Opacity: <span id="maskOpacityValue">65</span>%</label>
                                <div class="slider-group">
                                    <input type="range" id="maskOpacitySlider" class="form-control" min="0" max="100" value="65" aria-labelledby="maskOpacityValue">
                                    <input type="number" id="maskOpacityNumber" class="form-control" min="0" max="100" value="65" aria-label="Mask Opacity Percentage">
                                </div>
                                <p class="text-xs text-text-medium mt-1">Adjusts the dimness of the area outside the hex mask.</p>
                            </div>
                            <div class="action-buttons" style="margin-top: var(--spacing-unit);">
                                <button type="button" id="resetCropSettingsBtn" class="btn btn-neutral">Reset Adjustments</button>
                            </div>
                        </div>
                    </div>

                    <div class="visage-shaper__panel">
                        <h2 id="hexagonal-preview-title" class="section-title">Hexagonal Preview</h2>
                        <div class="visage-shaper__preview-panel">
                            <div id="visageCropResultPreview" class="visage-shaper__result-preview hex-card-shape" aria-label="Live preview of the cropped hexagonal image">
                                </div>
                            <p class="text-xs text-text-medium mt-2">This is how your image will appear on the card.</p>
                        </div>
                        <div class="visage-shaper__actions" style="margin-top: auto; padding-top:var(--spacing-unit)*2;">  <button type="button" class="btn btn-neutral" id="cancelVisageChangesBtn" data-screen-link="scriptorium">Cancel</button>
                           <button type="button" class="btn btn-neutral" id="saveVisageAsNewBtn">Save as New Image</button>
                           <button type="button" class="btn btn-secondary" id="applyVisageCropBtn">Apply to Card</button>
                        </div>
                    </div>
                </div>
            </section>

            <section id="collection-forge" class="screen content-screen-padding">
                </section>
        </main>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Global Navigation & Screen Management ---
    const mainNavLinks = document.querySelectorAll('.app-sidebar__nav-link.data-nav-link');
    const gatewayScreenLinks = document.querySelectorAll('#gateway [data-screen-link]');
    // Add other screen change triggers here if any (e.g., buttons inside screens)
    const visageShaperActionButtons = document.querySelectorAll('#visage-shaper [data-screen-link]');
    const allScreenChangeLinks = [...mainNavLinks, ...gatewayScreenLinks, ...visageShaperActionButtons];


    const screens = document.querySelectorAll('.screen');
    const appSidebar = document.getElementById('appSidebar');
    const mobileMenuToggleBtn = document.getElementById('mobileMenuToggle');
    const mainWorkspaceEl = document.getElementById('mainWorkspace');

    function showScreen(screenId) {
        // ... (existing screen switching logic - ensure it's robust) ...
        let screenFocused = false;
        screens.forEach(screen => {
            const isActive = screen.id === screenId;
            screen.classList.toggle('active', isActive);
            if(isActive) {
                screen.setAttribute('tabindex', '-1'); 
                requestAnimationFrame(() => { screen.focus(); screenFocused = true; });
            } else {
                screen.removeAttribute('tabindex');
            }
        });
        mainNavLinks.forEach(link => {
            const isActive = link.dataset.screen === screenId;
            link.classList.toggle('active-nav-link', isActive);
            link.setAttribute('aria-current', isActive ? 'page' : 'false');
        });
        if (window.innerWidth <= 768 && appSidebar.classList.contains('app-sidebar--open')) {
            appSidebar.classList.remove('app-sidebar--open');
            if(mobileMenuToggleBtn) mobileMenuToggleBtn.setAttribute('aria-expanded', 'false');
            document.body.classList.remove('sidebar-open');
        }
        if (!screenFocused && mainWorkspaceEl) mainWorkspaceEl.focus();
    }

    allScreenChangeLinks.forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const screenId = link.dataset.screenLink || link.dataset.screen;
            if (screenId) showScreen(screenId);
        });
    });
    
    if (mobileMenuToggleBtn && appSidebar) { /* ... existing mobile menu logic ... */ }
    document.addEventListener('click', (event) => { /* ... existing click outside to close mobile menu ... */ });

    // --- Scriptorium Logic (Placeholder - assumed to exist from previous steps) ---
    function validateAndPreviewScriptorium() { /* ... */ }
    function populateInitialScriptoriumPreview() { /* ... */ }
    // ... other Scriptorium functions and event listeners ...
    const cardImageUpload = document.getElementById('cardImageUpload'); // Scriptorium's upload

    // --- Visage Shaper ---
    const visageImageUpload = document.getElementById('visageImageUpload');
    const visageImageToCrop = document.getElementById('visageImageToCrop');
    const visageInteractiveHexMask = document.getElementById('visageInteractiveHexMask');
    const visageCroppingAreaContainer = document.getElementById('visageCroppingAreaContainer');
    const visageCropResultPreview = document.getElementById('visageCropResultPreview');

    const imageScaleSlider = document.getElementById('imageScaleSlider');
    const imageScaleNumber = document.getElementById('imageScaleNumber');
    const imageScaleValueDisplay = document.getElementById('imageScaleValue');
    const imageRotationSlider = document.getElementById('imageRotationSlider');
    const imageRotationNumber = document.getElementById('imageRotationNumber');
    const imageRotationValueDisplay = document.getElementById('imageRotationValue');
    const maskOpacitySlider = document.getElementById('maskOpacitySlider');
    const maskOpacityNumber = document.getElementById('maskOpacityNumber');
    const maskOpacityValueDisplay = document.getElementById('maskOpacityValue');
    const resetCropSettingsBtn = document.getElementById('resetCropSettingsBtn');
    const applyVisageCropBtn = document.getElementById('applyVisageCropBtn');
    const cancelVisageChangesBtn = document.getElementById('cancelVisageChangesBtn');
    const saveVisageAsNewBtn = document.getElementById('saveVisageAsNewBtn');
    const visageImageErrorEl = document.getElementById('visageImageError');


    let visageState = {
        imgOriginalWidth: 0,
        imgOriginalHeight: 0,
        imgCurrentScale: 1,
        imgCurrentRotation: 0,
        imgTranslateX: 0, // For image panning within its container
        imgTranslateY: 0,
        maskX: 0, // Mask position relative to image container (px)
        maskY: 0,
        maskWidth: 0, // Mask dimensions (px)
        maskHeight: 0,
        maskOpacity: 0.65, // Default from CSS
        isMaskDragging: false,
        isMaskResizing: false,
        resizeHandle: null,
        dragStartX: 0, dragStartY: 0,
        maskStartLeft: 0, maskStartTop: 0, maskStartWidth: 0, maskStartHeight: 0
    };

    function initializeVisageShaper() {
        if (!visageImageToCrop || !visageInteractiveHexMask || !visageCroppingAreaContainer) return;

        const containerRect = visageCroppingAreaContainer.getBoundingClientRect();
        
        // Initial mask size and position (centered, e.g., 60% of smaller dimension)
        const baseSize = Math.min(containerRect.width, containerRect.height) * 0.6;
        visageState.maskWidth = baseSize;
        visageState.maskHeight = baseSize * 1.15; // Hex aspect ratio
        visageState.maskX = (containerRect.width - visageState.maskWidth) / 2;
        visageState.maskY = (containerRect.height - visageState.maskHeight) / 2;

        visageInteractiveHexMask.style.width = `${visageState.maskWidth}px`;
        visageInteractiveHexMask.style.height = `${visageState.maskHeight}px`;
        visageInteractiveHexMask.style.left = `${visageState.maskX}px`;
        visageInteractiveHexMask.style.top = `${visageState.maskY}px`;
        
        // Reset image transform
        visageState.imgCurrentScale = 1;
        visageState.imgCurrentRotation = 0;
        visageState.imgTranslateX = 0;
        visageState.imgTranslateY = 0;
        visageImageToCrop.style.transform = `translate(${visageState.imgTranslateX}px, ${visageState.imgTranslateY}px) scale(${visageState.imgCurrentScale}) rotate(${visageState.imgCurrentRotation}deg)`;

        if(imageScaleSlider) imageScaleSlider.value = 100;
        if(imageScaleNumber) imageScaleNumber.value = 100;
        if(imageScaleValueDisplay) imageScaleValueDisplay.textContent = 100;
        if(imageRotationSlider) imageRotationSlider.value = 0;
        if(imageRotationNumber) imageRotationNumber.value = 0;
        if(imageRotationValueDisplay) imageRotationValueDisplay.textContent = 0;
        if(maskOpacitySlider) maskOpacitySlider.value = 65;
        if(maskOpacityNumber) maskOpacityNumber.value = 65;
        if(maskOpacityValueDisplay) maskOpacityValueDisplay.textContent = 65;
        visageInteractiveHexMask.style.boxShadow = `0 0 0 9999px rgba(0,0,0,${visageState.maskOpacity})`;


        updateVisagePreview();
    }
    
    function handleVisageImageUpload(file) {
        if (!file) return;
        if (!file.type.startsWith('image/')){ 
            if(visageImageErrorEl) visageImageErrorEl.textContent = "Invalid file type. Please select an image.";
            return; 
        }
        if (file.size > 5 * 1024 * 1024) { 
            if(visageImageErrorEl) visageImageErrorEl.textContent = "File too large. Maximum 5MB.";
            return;
        }
        if(visageImageErrorEl) visageImageErrorEl.textContent = "";

        const reader = new FileReader();
        reader.onload = (e) => {
            visageImageToCrop.src = e.target.result;
            visageImageToCrop.onload = () => { // Wait for image to be loaded to get natural dimensions
                visageState.imgOriginalWidth = visageImageToCrop.naturalWidth;
                visageState.imgOriginalHeight = visageImageToCrop.naturalHeight;
                initializeVisageShaper(); // Reset positions and scales for new image
            };
            if (visageImageToCrop.complete) visageImageToCrop.onload(); // If already loaded from cache
        }
        reader.readAsDataURL(file);
    }

    if (visageImageUpload) {
        visageImageUpload.addEventListener('change', (e) => handleVisageImageUpload(e.target.files[0]));
        // Basic drag and drop for the input itself
        visageImageUpload.addEventListener('dragover', (e) => e.preventDefault());
        visageImageUpload.addEventListener('drop', (e) => {
            e.preventDefault();
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                visageImageUpload.files = e.dataTransfer.files;
                const event = new Event('change', { bubbles: true });
                visageImageUpload.dispatchEvent(event);
            }
        });
    }
    
    // Mask Dragging
    if (visageInteractiveHexMask && visageCroppingAreaContainer) {
        visageInteractiveHexMask.addEventListener('mousedown', (e) => {
            if (e.target !== visageInteractiveHexMask && !e.target.classList.contains('resize-handle')) return; // Only drag mask if mousedown on mask itself or its handles

            if (e.target.classList.contains('resize-handle')) {
                visageState.isMaskResizing = true;
                visageState.resizeHandle = e.target.dataset.direction;
            } else {
                visageState.isMaskDragging = true;
            }
            
            visageState.dragStartX = e.clientX;
            visageState.dragStartY = e.clientY;
            visageState.maskStartLeft = visageInteractiveHexMask.offsetLeft;
            visageState.maskStartTop = visageInteractiveHexMask.offsetTop;
            visageState.maskStartWidth = visageInteractiveHexMask.offsetWidth;
            visageState.maskStartHeight = visageInteractiveHexMask.offsetHeight;
            visageInteractiveHexMask.style.cursor = visageState.isMaskResizing ? getResizeCursor(visageState.resizeHandle) : 'grabbing';
            document.body.style.cursor = visageInteractiveHexMask.style.cursor; // Apply cursor to body to avoid losing it
            e.preventDefault();
        });
    }

    document.addEventListener('mousemove', (e) => {
        if (!visageState.isMaskDragging && !visageState.isMaskResizing) return;
        
        const dx = e.clientX - visageState.dragStartX;
        const dy = e.clientY - visageState.dragStartY;
        const containerRect = visageCroppingAreaContainer.getBoundingClientRect();

        if (visageState.isMaskDragging) {
            let newX = visageState.maskStartLeft + dx;
            let newY = visageState.maskStartTop + dy;
            newX = Math.max(0, Math.min(newX, containerRect.width - visageInteractiveHexMask.offsetWidth));
            newY = Math.max(0, Math.min(newY, containerRect.height - visageInteractiveHexMask.offsetHeight));
            visageInteractiveHexMask.style.left = `${newX}px`;
            visageInteractiveHexMask.style.top = `${newY}px`;
        } else if (visageState.isMaskResizing) {
            // Simplified resize logic - this needs to be more sophisticated for true hex resizing
            // This example will just scale from center or adjust width/height based on handle
            let newWidth = visageState.maskStartWidth;
            let newHeight = visageState.maskStartHeight;
            let newLeft = visageState.maskStartLeft;
            let newTop = visageState.maskStartTop;
            const aspectRatio = 1 / 1.15; // width / height for vertical hex

            if (visageState.resizeHandle.includes('e')) newWidth = Math.max(20, visageState.maskStartWidth + dx);
            if (visageState.resizeHandle.includes('w')) {
                newWidth = Math.max(20, visageState.maskStartWidth - dx);
                newLeft = visageState.maskStartLeft + dx;
            }
            if (visageState.resizeHandle.includes('s')) newHeight = Math.max(20, visageState.maskStartHeight + dy);
            if (visageState.resizeHandle.includes('n')) {
                newHeight = Math.max(20, visageState.maskStartHeight - dy);
                newTop = visageState.maskStartTop + dy;
            }
            // Maintain aspect ratio (simplified, pick one dimension to drive the other)
            if (visageState.resizeHandle.includes('e') || visageState.resizeHandle.includes('w')) {
                newHeight = newWidth / aspectRatio;
            } else if (visageState.resizeHandle.includes('n') || visageState.resizeHandle.includes('s')) {
                newWidth = newHeight * aspectRatio;
            }
            // Prevent going outside bounds (simplified)
            if (newLeft < 0) { newWidth += newLeft; newLeft = 0; }
            if (newTop < 0) { newHeight += newTop; newTop = 0; }
            if (newLeft + newWidth > containerRect.width) newWidth = containerRect.width - newLeft;
            if (newTop + newHeight > containerRect.height) newHeight = containerRect.height - newTop;


            visageInteractiveHexMask.style.width = `${newWidth}px`;
            visageInteractiveHexMask.style.height = `${newHeight}px`;
            visageInteractiveHexMask.style.left = `${newLeft}px`;
            visageInteractiveHexMask.style.top = `${newTop}px`;
        }
        requestAnimationFrame(updateVisagePreview);
    });

    document.addEventListener('mouseup', () => {
        if (visageState.isMaskDragging || visageState.isMaskResizing) {
            visageState.isMaskDragging = false;
            visageState.isMaskResizing = false;
            visageInteractiveHexMask.style.cursor = 'move';
            document.body.style.cursor = 'default';
        }
    });
    
    function getResizeCursor(direction) {
        if (direction === 'n' || direction === 's') return 'ns-resize';
        if (direction === 'e' || direction === 'w') return 'ew-resize';
        if (direction === 'ne' || direction === 'sw') return 'nesw-resize';
        if (direction === 'nw' || direction === 'se') return 'nwse-resize';
        return 'default';
    }


    // Control Panel Sliders
    function setupSliderSync(sliderEl, numberInputEl, valueDisplayEl, stateProperty, isRotation = false, isOpacity = false) {
        if (!sliderEl || !numberInputEl || !valueDisplayEl) return;
        const updateFn = () => {
            const value = parseFloat(sliderEl.value);
            numberInputEl.value = value;
            valueDisplayEl.textContent = value;
            if (isRotation) visageState.imgCurrentRotation = value;
            else if (isOpacity) {
                 visageState.maskOpacity = value / 100;
                 visageInteractiveHexMask.style.boxShadow = `0 0 0 9999px rgba(0,0,0,${visageState.maskOpacity})`;
            }
            else visageState.imgCurrentScale = value / 100; // Assuming scale is percentage
            
            if (!isOpacity) { // Opacity doesn't affect image transform directly
                 visageImageToCrop.style.transform = `translate(${visageState.imgTranslateX}px, ${visageState.imgTranslateY}px) scale(${visageState.imgCurrentScale}) rotate(${visageState.imgCurrentRotation}deg)`;
            }
            requestAnimationFrame(updateVisagePreview);
        };
        sliderEl.addEventListener('input', updateFn);
        numberInputEl.addEventListener('change', () => { // Use change for number input to avoid too many updates
            sliderEl.value = numberInputEl.value;
            updateFn();
        });
    }

    setupSliderSync(imageScaleSlider, imageScaleNumber, imageScaleValueDisplay, 'imgCurrentScale');
    setupSliderSync(imageRotationSlider, imageRotationNumber, imageRotationValueDisplay, 'imgCurrentRotation', true);
    setupSliderSync(maskOpacitySlider, maskOpacityNumber, maskOpacityValueDisplay, 'maskOpacity', false, true);

    if (resetCropSettingsBtn) {
        resetCropSettingsBtn.addEventListener('click', initializeVisageShaper);
    }

    function updateVisagePreview() {
        if (!visageImageToCrop || !visageInteractiveHexMask || !visageCropResultPreview || !visageCroppingAreaContainer || !visageImageToCrop.complete || visageState.imgOriginalWidth === 0) return;

        const img = visageImageToCrop;
        const mask = visageInteractiveHexMask;
        const preview = visageCropResultPreview;
        const container = visageCroppingAreaContainer;

        // Get current transforms of the image
        const imgTransform = new DOMMatrixReadOnly(window.getComputedStyle(img).transform);
        const currentScale = Math.sqrt(imgTransform.a * imgTransform.a + imgTransform.b * imgTransform.b); // General way to get scale
        const currentRotationRad = Math.atan2(imgTransform.b, imgTransform.a);

        // Mask position relative to the container
        const maskRect = mask.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        const maskX_in_container = maskRect.left - containerRect.left;
        const maskY_in_container = maskRect.top - containerRect.top;
        
        // Calculate the effective top-left of the image *within the container* after transforms
        // This is complex. A simpler approach for preview:
        // Assume image center is transform-origin.
        // Calculate where the mask's center is relative to the image's center.
        
        const imgCenterX_in_container = containerRect.width / 2 + visageState.imgTranslateX; // Assumes image is centered initially then translated
        const imgCenterY_in_container = containerRect.height / 2 + visageState.imgTranslateY;
        
        const maskCenterX_in_container = maskX_in_container + maskRect.width / 2;
        const maskCenterY_in_container = maskY_in_container + maskRect.height / 2;

        // Vector from image center to mask center (in scaled, rotated image space)
        let dx_img_mask = maskCenterX_in_container - imgCenterX_in_container;
        let dy_img_mask = maskCenterY_in_container - imgCenterY_in_container;

        // Inverse rotate this vector to align with unrotated image
        const cosR = Math.cos(-currentRotationRad);
        const sinR = Math.sin(-currentRotationRad);
        const dx_unrotated = dx_img_mask * cosR - dy_img_mask * sinR;
        const dy_unrotated = dx_img_mask * sinR + dy_img_mask * cosR;

        // Convert to coordinates on the original natural image
        const cropCenterX_natural = (visageState.imgOriginalWidth / 2) + (dx_unrotated / currentScale);
        const cropCenterY_natural = (visageState.imgOriginalHeight / 2) + (dy_unrotated / currentScale);
        
        const cropWidth_natural = maskRect.width / currentScale;
        const cropHeight_natural = maskRect.height / currentScale;

        const cropX_natural = cropCenterX_natural - cropWidth_natural / 2;
        const cropY_natural = cropCenterY_natural - cropHeight_natural / 2;

        // Store for apply
        visageState.cropParams = {
            x: cropX_natural, y: cropY_natural,
            width: cropWidth_natural, height: cropHeight_natural,
            rotation: visageState.imgCurrentRotation // Store rotation for potential canvas cropping
        };
        
        // Update preview background
        preview.style.backgroundImage = `url('${img.src}')`;
        // Scale factor to fit the cropped natural area into the preview hex
        const previewScaleX = preview.offsetWidth / cropWidth_natural;
        const previewScaleY = preview.offsetHeight / cropHeight_natural;
        // Use the smaller scale to maintain aspect ratio and fit entirely
        const finalPreviewScale = Math.min(previewScaleX, previewScaleY);


        preview.style.backgroundSize = `${visageState.imgOriginalWidth * finalPreviewScale}px ${visageState.imgOriginalHeight * finalPreviewScale}px`;
        preview.style.backgroundPosition = `-${cropX_natural * finalPreviewScale}px -${cropY_natural * finalPreviewScale}px`;
        // Rotation of background is hard with just CSS background-image to match arbitrary crop rotation.
        // For a true rotated crop preview, a canvas is needed.
        // We can rotate the preview element itself, but it won't be a "cropped view of rotated image"
        preview.style.transform = `rotate(${visageState.imgCurrentRotation}deg)`; // Rotate preview to match image
    }
    const debouncedUpdateVisagePreview = debounce(updateVisagePreview, 50);


    if (applyVisageCropBtn) {
        applyVisageCropBtn.addEventListener('click', () => {
            if (!visageImageToCrop.src || visageImageToCrop.src.includes('placehold.co')) {
                alert("Please upload an image first."); return;
            }
            // In a real app, use visageState.cropParams to crop the image (e.g., on a canvas)
            // and then set the Scriptorium preview.
            // For this prototype, we'll conceptually pass the crop data.
            const { x, y, width, height, rotation } = visageState.cropParams;
            const previewImageContainer = document.getElementById('previewImageContainer'); // Scriptorium's preview
            const editorImagePreviewContainer = document.getElementById('editorImagePreviewContainer');

            alert(`Applying crop (conceptual):\nX: ${x.toFixed(2)}, Y: ${y.toFixed(2)}\nWidth: ${width.toFixed(2)}, Height: ${height.toFixed(2)}\nRotation: ${rotation}°`);
            
            // Update Scriptorium preview using background properties for a better visual
            // This requires Scriptorium's preview to be a div, not an img tag for this method.
            // The current Scriptorium setup uses a div with background image already.
            if (previewImageContainer) {
                previewImageContainer.style.backgroundImage = `url('${visageImageToCrop.src}')`;
                const scriptoriumPreviewWidth = previewImageContainer.offsetWidth;
                const scaleFactor = scriptoriumPreviewWidth / width;
                previewImageContainer.style.backgroundSize = `${visageState.imgOriginalWidth * scaleFactor}px ${visageState.imgOriginalHeight * scaleFactor}px`;
                previewImageContainer.style.backgroundPosition = `-${x * scaleFactor}px -${y * scaleFactor}px`;
                previewImageContainer.style.transform = `rotate(${rotation}deg)`;
                document.getElementById('previewImagePlaceholder').style.display = 'none';
            }
             if (editorImagePreviewContainer) { // Also update the small editor preview
                editorImagePreviewContainer.style.backgroundImage = `url('${visageImageToCrop.src}')`;
                const editorPreviewWidth = editorImagePreviewContainer.offsetWidth;
                const scaleFactorEditor = editorPreviewWidth / width;
                editorImagePreviewContainer.style.backgroundSize = `${visageState.imgOriginalWidth * scaleFactorEditor}px ${visageState.imgOriginalHeight * scaleFactorEditor}px`;
                editorImagePreviewContainer.style.backgroundPosition = `-${x * scaleFactorEditor}px -${y * scaleFactorEditor}px`;
                editorImagePreviewContainer.style.transform = `rotate(${rotation}deg)`;
                document.getElementById('editorImagePlaceholder').style.display = 'none';

            }

            showScreen('scriptorium');
        });
    }
    if (cancelVisageChangesBtn) cancelVisageChangesBtn.addEventListener('click', () => showScreen('scriptorium'));
    if (saveVisageAsNewBtn) saveVisageAsNewBtn.addEventListener('click', () => alert("Save as New Image: Functionality to be implemented. Crop data logged to console."));


    // --- Obsidian Library & Collection Forge (Condensed, from previous logic) ---
    // ... (Library and Collection Forge JS, ensure it doesn't conflict) ...
    const libraryCardGrid = document.getElementById('libraryCardGrid');
    if (libraryCardGrid) { /* ... Library population logic ... */ }
    const packCardListEl = document.getElementById('packCardList');
    if (packCardListEl) { /* ... Collection Forge population logic ... */ }
    
    // Initial Setup
    populateInitialScriptoriumPreview(); 
    validateAndPreviewScriptorium(); 
    initializeVisageShaper(); // Initialize cropper
    
    // Set Visage Shaper as default active screen
    showScreen('visage-shaper'); 
});
</script>
</body>
</html>
